package uwi.dcit.agriexpensesvr;

import com.google.api.server.spi.config.Api;
import com.google.api.server.spi.config.ApiMethod;
import com.google.api.server.spi.config.ApiMethod.HttpMethod;
import com.google.api.server.spi.config.ApiNamespace;
import com.google.appengine.api.NamespaceManager;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;

import javax.inject.Named;
import javax.persistence.EntityNotFoundException;
import javax.persistence.EntityManager;


//http://www.objectdb.com/java/jpa/persistence/store
//http://www.objectdb.com/java/jpa/query/execute

@Api(name = "accountApi",
        version = "v1",
        namespace = @ApiNamespace(
                ownerDomain = "agriexpensesvr.dcit.uwi",
                ownerName = "agriexpensesvr.dcit.uwi",
                packagePath = ""
        ))
public class AccountEndpoint {

    private static EntityManager getEntityManager() {
        return EMF.getManagerInstance();
        //return EMF.get().createEntityManager();
    }

    /**
     *This inserts a new entity into App Engine data store. If the entity
     * already exists it simply returns the existing entity. It uses HTTP POST method.
     *
     * @param namespace The name space generated by the user email address attained from the client
     * @param country The country to which the account is associated with
     * @param county The location/subzone within the country that the user is located/registered in
     * @return Returns created or existing account , will return null if operation fails
     */
    @ApiMethod(name="getOrInsertAccount")
    public Account create(@Named("namespace")String namespace, @Named("country") String country, @Named("county")String county){
        NamespaceManager.set(namespace); // Namespace compartmentalize data to prevent access from other users of different namespaces

        EntityManager em = getEntityManager();

        Key k = KeyFactory.createKey("Account", namespace); //TCreate the key for the account based on the namespace supplied
        Account account = new Account(k, KeyFactory.keyToString(k), -1, namespace);
        account.setCountry(country);
        account.setCounty(county);

        if (!containsAccount(account, em)){ // Account does not previously exist
            try{
                em.getTransaction().begin();
                em.persist(account);
                em.getTransaction().commit();
            }catch(Exception e){
                e.printStackTrace();
                account = null; // Return null to indicate failed attempt at creating an account
            }
            finally {
                //em.close();
            }
        }else{
            System.out.println("Account Previously Exists");
            account = retrieve(namespace); // Retrieve th
        }
        return account;
    }

    /**
     * This attempts to pull the account identified by the namespace supplied.
     * @param namespace The String namespace that will be used to identify the account. This is typically the email address without the domain
     * @return The Account identified by the namespace supplied. If the namespace does not exist method will return null
     */
    @ApiMethod(name="getAccount", httpMethod = HttpMethod.GET)
    public Account retrieve(@Named("namespace") String namespace){
        NamespaceManager.set(namespace);
        EntityManager em = getEntityManager();

        Account account = em.find(Account.class, KeyFactory.createKey("Account", namespace));
        if (account == null)System.out.println("Unable to Find account associated with namespace  :"+namespace);
        else System.out.println("Found: " + account);
        //em.close();
        return account;
    }

    /**
     * Use to update information that exist within the database for the user
     * @param accountUpdate
     * @return
     */
    @ApiMethod(name="updateAccount", httpMethod = HttpMethod.PUT)
    public Account update(Account accountUpdate){
        NamespaceManager.set(accountUpdate.getAccount());
        EntityManager em = getEntityManager();
        Account account = em.find(Account.class, KeyFactory.createKey("Account", accountUpdate.getAccount()));
        if (!containsAccount(account, em))
            throw new EntityNotFoundException("Account with namespace:    " + account.getAccount() +" does not exist");
        else{
            if(accountUpdate.getAddress()!=null)
                account.setAddress(accountUpdate.getAddress());
            if(accountUpdate.getCountry()!=null)
                account.setCountry(accountUpdate.getCountry());
            if(accountUpdate.getCounty()!=null)
                account.setCounty(accountUpdate.getCounty());
            if(accountUpdate.getLastUpdated()!=0)
                account.setLastUpdated(accountUpdate.getLastUpdated());
            em.getTransaction().begin();
            em.persist(account);
            em.getTransaction().commit();
            return account;
        }
        //em.close();
        //return accountUpdate;
    }

    @ApiMethod(name="removeAccount", httpMethod = HttpMethod.DELETE)
    public void delete(@Named("namespace") String namespace){
        NamespaceManager.set(namespace);
        EntityManager em = getEntityManager();
        Account account = retrieve(namespace);
        em.getTransaction().begin();
        em.remove(account);
        em.getTransaction().commit();
        //em.close();
    }

    private boolean containsAccount(Account account, EntityManager em) {
        return (em.find(Account.class, account.getKey()) != null);
    }
}